# Python Code Style Guideline by Misty
## Внешний вид кода
* **Кейс**: snake_case для названий переменных (SNAKE_CASE для названий констант), функций и методов. PascalCase для названий классов. Аббревиатуры строчными буквами. Ключи словарей - в snake_case. Ключи JSON-объектов в camelCase, но если два Python-приложения общаются посредством JSON - тогда ключи JSON-объекта в snake_case.
* **Индентация**: 4 пробела.
* **Type hints**: **Обязательно** использование при указании параметров функции и её return value (символ `->` окружается пробелами). В остальных случаях (объяление переменных, получение данных из внешних источников) - использование желательно, если это повысит читаемость кода. Оформение - без пробела перед двоеточием, пробел после доеточия, тип (Пример: `foo: int`); Если после тайп хинта идёт оператор `=`, вокруг этого оператора стоят пробелы (Пример: `foo: int = 1`). Злоупотребление тайп хинтами не рекомендуется. При указании сложного объекта (список, список словарей, словарь со списами и т.п.) в качесте тайп хинта, **обязательно** использовать полное описание типа объекта (не `: list`, а `" list[str]`), в этом могут помочь тайп алиасы. Использовать тип `Any` не запрещено в случае если практически невозможно предугадать тип объекта или если объект слишком сложный (генератор или корутина и т.п.).
* **Длина строки кода**: **строго** 80 символов.
* **Комментарии**: допустимы, *настоятельно* рекомендуется избегать откомментированного кода. Если коммантарий находится на той же строке, что и код, **необходимо** отступить два пробела от кода, поставить символ `#`, а затем отступить от этого символа ещё один пробел. Пример: 
    ```
    foo = 1  # Два пробела, символ, один пробел, текст комментария
    ```
* **Раздление пустыми строками**: две пустые строки до и после объявления функции и класса. Логические блоки внутри функции, метода или просто в коде разделяются одним пробелом, или, в случае, когда его не хватает, комментарием (такого вида: `# ------`)
* **Работа с операторами**: между любыми операторами всегда пробелы, кроме случаев работы с функциями - см. ниже.
* **Переносы скобок, работа с объектами**: 
    * Первая скобка остаётся на той же строке, вторая скобка **обязательно** переносится на новую строку в начало индентации. Содержимое между скобок индентируется на четыре пробела. В случае переноса скобок добавляется висящая запятая, в остальных случаях, висящая запятая запрещена. Пример:
        ```
        foo = [
            1,
            2,
            3,
        ]
        ```
    * Исключение - сложный объект (список словарей и прочее). В этом случае первостепенна читаемость кода. Рекомендуется переносить первую скобку на новую строку. Пример:
        ```
        foo = [
            {
                ‘bar’: 1,
                ‘baz’: 2,
            },
            {
                ‘bar’: 3,
                ‘baz’: 4
            },
        ]
        ```
    * При переносе выражения, бинарные операторы остаются на строке своего первого операнда. Пример:
        ```
        flag = False
        if (
            foo == 'Hello' and
            bar == 'World' and
            baz == '!' and
            not flag
        ):
        ```
* **Докстринги (DocStrings)**: использование *настоятельно* рекомендуется. Для VSCode советую вот это расширение (вставить эту строку в поиск расширений): `njpwerner.autodocstring`. С этим расширением будет создаваться докстринга следующего вида, причём заполнятся она будет атоматически:
    ```
    """_summary_

    Args:
        arg_1 (_type_): _description_
        arg_2 (_type_): _description_

    Returns:
        _type_: _description_
    """
    ```
* **Оформление функций и методов**: 
    * При объявлении функции или метода, правила переноса скобок и работы с тайп хинтами здесь работают как обычно. При вызове работают обычные правила, но передача keyword аргументов в функцию - исключение. Пробелы вокруг оператора присваивания **запрещены**.
    ```
    def some_very_very_long_function_name_with_many_args(
        arg_1: int = 1,
        arg_2: str | None = None,
        arg_3: list[dict[str, Any]] | None = None
    ) -> str:
        result = arg_2 * arg_1
        return result


    foo = some_very_very_long_function_name_with_many_args(
        arg_1=1000,
        arg_2='bar',
    )
    ```
    * Возвращать выражение - **запрещено**, исключение - тернарный оператор. Пример:
    ```
    def foo(a: int, b: int) -> int:
        return pow(a, b)  # Так делать нельзя
    

    def bar(a: int, b: int) -> int:
        c = pow(a, b)
        return c  # Надо делать так

    def baz(a: int, b: int, flag: bool) -> int:
        return a if flag else b  # Так можно
    ```
* **Переносы выражений, строк**: В случае если длина выражения или строки превышает лимит в 80 символов, есть два варианта.
    * Первый вариант - использование обратного слэша `\`. Рекомендуется использовать с выражениями, при условии, что потребуется только один обратный слэш. **Нельзя** переносить квадратные скобки. Оформлeние - без пробела перед символом, после переноса индентация уходит на четыре пробела. Пример:
    ```
    foo = bar['some_long_long_dictionary_key'].method_1().method_2().method_3()\
        .method_4()['key']
    ```
    * Второй вариант - использование круглых скобок `()`. Рекомендуется использовать со строками, а также с очень длинными цепочками методов, если одного `\` не хватает, чтобы уложиться в 80 символов. Пример:
    ```
    foo = (
        'foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobar'
        'foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobar'
        'foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobar'
    )
    bar = (
        session.query(
            SomeModel.some_field,
            OtherModel.other_field,
        )
        .filter(SomeModel.some_field == 1)
        .group_by(OtherModel.other_field)
        .all()
    )
    ```
* **Импорты, работа с `__init__.py`**: 
    * Импорты: в первую очередь импортируются стандартные библиотеки, затем сторонние библиотеки, затем собственные модули. Между этими категориями отступы в одну строку, между импортами и кодом отступ в две строки. В случае, когда из модуля импортируется множество объектов, и они не помещаются в лимит в 80 символов, следует пользоваться круглыми скобками, соблюдая правила переноса. **wildcard-импорты (`from foo import *`) запрещены**. Пример:
        ```
        import os

        from foo import (
            bar_1,
            bar_2,
            bar_3,
            bar_4,
            bar_5,
        )

        from . import foobar


        baz = foobar.somefunc(bar_1, bar_2)
        ```
    * `__init__.py`: **wildcard-импорты запрещены**. Импортируются только необходимые файлы и подмодули, причём из верхних уровней абстракции. Файл `__init__.py` **всегда** оформляется следующим образом:
        ```
        from . import foo
        from . import bar
        from . import baz
        ```
* Логическое ветвление, операторы `if`, `elif`, `else`, `match`:
    * Использование `else`, когда в нём нет необходимости не возбраняется.
    * `match` или `if/else`?
        * `match`: использовать когда речь идёт о реакции на внешний инпут или флаг, либо когда функционал этого ключевого слова превышает функционал `if/else`.
        * `if/else`: использовать при логических развилках.
* Циклы, list (dict) comprehension:
    * Синтаксис `for: ... else:` **запрещён** если не поставлен разъясняющий комментарий.
    * По возможности испльзовать цикл `for`, а не `while`.
    * Если list comprehension сложнее одного `if` или тернарного оператора, для построения списка использовать **только** цикл.
    * Использовать dict comprehension не рекомендуется.
* Exceptions:
    * При использовании конструкции ключевых слов `else` и `finally` в сочетании с `try: ... except ... as ...: ...` **всегда** оставлять поясняющие комментарии.
    * Отлавливать **всегда** только конкретные исключения, выражения `except:` и `except Exception:` **строго запрещены**.
* **Прочее**: Если здесь что-то не указано - **обязательно** обращаться к PEP8 и/или примерам из документации Python. Если там нет однозначного ответа, первостепенна читаемость кода.
## Архитектура проекта, файловая система
* **Архитектура проекта**:
    * **Бэкенд-приложения**: Предполагается что на Python будут писаться бэкенд-приложения, в связи с этим должна использоваться стандартная модель MVC (Model, View, Controller).
        * Model - отдельная директория (модуль) для работы с базой данных. Здесь находятся как модели (как одним файлом, так и по отдельному файлу для каждой модели - в зависимости от числа моделей), так и функции для работы с базой данных.
        * View - файл с раутами API. Здесь должно быть минимум кода и логики и максимум документации. В FastAPI - это файл `main.py`. URL-адреса бэкенд приложения должны быть написаны в snake_case.
        * Controller - модуль, отвечающий за логику приложения. Если у проекта нет отдельной точки входа (`main.py`), она должна находится здесь. Файлы этого модуля должны разделяться по функционалу, если кода в файле слишком много, следует создать подмодуль. Например, все функции для работы с блокчейном - в отдельном файле `blockchain.py`, все функции для работы со сторонним API - в отдельном файле с названием этого API. Также в этом модуле может присутствовать подмодуль `utils`, в котором будут хранится файлы с часто используемыми сторонними функциями, которые могут быть использованы во всех подмодулях модуля `controllers`, например: `redis_cache.py`, `logs.py` и т.п. 
        **Важно**: нельзя допускать взаимодействие модулей напрямую между собой, только через верхний уровень абстракции (отдельный файл, в который импортируются все подмодули), исключением может являться только файл `data_processing.py` - файл для обработки данных такими библиотеками как Pandas (этот функционал в той или иной мере может быть востребован в любом модуле, но иногда он слишком важен, чтобы класть его в `utils`).
        * Внутренние константы приложения стоит хранить в `utils`, в файлу `constants.py`. Общие константы хранить в общих конфигах и/или в переменных окружения.
    * **Микросервиса для обработки данных и/или любой другой программы на Python**: в этом случае стоит придерживаться той же логики, что и в параграфе про Controller выше.
* **Файловая система**:
    * Кириллица в названии файлов **запрещена**.
    * Названия файлов **только** в snake_case, без пробелов и прочих символов (разрешены только буквы латинского алфавита, символ `_` и цифры).
    * При работе с файлами использовать **только** относительные адреса и библиотеку `pathlib`.

# База данных
* Тип базы данных определяется перед началом работы с проектом, по умолчанию - PostgreSQL.
* Все таблицы и поля в них должны быть записаны **строго** в snake_case.
* Архитектура базы данных, типы, отношения должны обговариваться на общем собрании.
* У проекта **всегда** должна быть актуальная схема базы данных
